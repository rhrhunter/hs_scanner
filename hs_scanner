#!/usr/bin/perl

use strict;
use warnings;
use Data::Dump qw(dump);
use Cwd;
use v5.18;

my $CWD = getcwd();
my $WINS = 0;
my $LOSSES = 0;
my $SPECTATING = 0;
my $MATCHUP_SINGLE;
my $MATCHUP_ALL;
my $MATCHUP_GLOBAL;

sub enable_logging {
    `mkdir -p ~/Library/Preferences/Blizzard/Hearthstone/`;

    my @logspecs = (
        "[Zone]",
        "[Ben]",
        "[Bob]",
        "[Power]",
        #"[Net]",
        #"[Rachelle]",
        #"[Kyle]",
        #"[FaceDownCard]",
        #"[Derek]",
        #"[Mike]",
        #"[Bob]",
        #"[Cameron]"
    );

    my $i = 0;
    foreach my $spec (@logspecs) {
        my $mode = ">>";
        if ($i == 0) {
            $mode = ">";
        }
        $i++;

        `echo "$spec" $mode ~/Library/Preferences/Blizzard/Hearthstone/log.config`;
        `echo "LogLevel=1" >> ~/Library/Preferences/Blizzard/Hearthstone/log.config`;
        `echo "FilePrinting=false" >> ~/Library/Preferences/Blizzard/Hearthstone/log.config`;
        `echo "ConsolePrinting=true" >> ~/Library/Preferences/Blizzard/Hearthstone/log.config`;
        `echo "ScreenPrinting=false" >> ~/Library/Preferences/Blizzard/Hearthstone/log.config`;
    }        
}

my ($player_log) = `ls ~/Library/Logs/Unity/Player.log`;
chomp($player_log);

sub init_player_log {
    `mkdir -p ~/Library/Logs/Unity`;
    `touch ~/Library/Logs/Unity/Player.log`;
    `echo "" > ~/Library/Logs/Unity/Player.log`;

    system("rm $CWD/hs_game.log");
}

my $result_change = 1;
sub display_results {
    my ($drawn_cards, $enemy_secrets, $enemy_cards, $friendly_player_entity) = @_;

    my @h = ();

    if ($MATCHUP_SINGLE) {
        push(@h, "$MATCHUP_SINGLE");
    }
    if ($MATCHUP_ALL) {
        push(@h, "$MATCHUP_ALL");
    }
    if ($MATCHUP_GLOBAL) {
        push(@h, "$MATCHUP_GLOBAL");
    }
    push(@h, 
         "Drawn Cards",   $drawn_cards,
         "Enemy Cards",   $enemy_cards,
         "Enemy Secrets", $enemy_secrets);
    
    if ($result_change) {
        system("clear");
        print Data::Dump::dump(\@h);
    }
    $result_change = 0;
}

sub msg {
    my ($msg) = @_;
    open (FH3, ">>", "$CWD/hs_game.log");
    print FH3 $msg . "\n";
    close(FH3);
}

sub scan_player_log {    
    msg("Opening File: $player_log");
    open(FH1, "<", "$player_log") or die("Could not open file: $player_log");
    
    my $drawn_cards   = {};
    my $enemy_secrets = {};
    my $enemy_cards   = {};
    my $current_enemy;
    my $friendly_hero;
    my $friendly_player_id = -1;
    my $game_over = 1;
    my $player_entities = {};
    my $friendly_player_entity;
    my $looked_up_records = 0;

    msg("Clearing out results");
    display_results($drawn_cards, $enemy_secrets, $enemy_cards, $friendly_player_entity);

    my $i = 0;
    while (1) {
	while (my $line = <FH1>) {
            $i++;

	    display_results($drawn_cards, $enemy_secrets, $enemy_cards, $friendly_player_entity);
            
	    chomp($line);

            if ($line =~ /^\[[A-Za-z]+?\]/) {
                #msg($line);
            }

	    # see if the game ended
	    if ($line =~ /\[Bob\] \-\-\-RegisterScreenEndOfGame\-\-\-/) {
		msg("Detected end of game.") if (!$game_over);
		$game_over = 1;
		next;
	    }

            # detect end of game
	    # [Power] PowerTaskList.DebugPrintPower() -     TAG_CHANGE Entity=GameEntity tag=STEP value=FINAL_GAMEOVER
	    if ($line =~ /\[Power\].+?value=FINAL_GAMEOVER/i) {
		msg("Detected end of game.") if (!$game_over);
		$game_over = 1;
		next;
	    }

            # detect end of spectator mode
            if ($line =~ /\[Power\].+?End Spectator Mode/) {
                msg("No longer spectating");
                $SPECTATING = 0;
                $game_over = 1;
                $result_change = 1;
                next;
            }

            # detect start of spectator mode
            if ($line =~ /\[Power\].+?Start Spectator Game/) {
                msg("Spectating a game.");
                $SPECTATING = 1;
                $game_over = 1;
                $result_change = 1;
                next;
            }
            
            # keep track of all player entities and their ID's
            # [Power] PowerTaskList.DebugPrintPower() -     TAG_CHANGE Entity=rtba tag=PLAYER_ID value=1
            if ($line =~ /\[Power\].+?TAG_CHANGE Entity=(.+?) tag=PLAYER_ID value=(\d+)/) {
                msg("Entity: $1 has ID: $2");
                $player_entities->{$2} = $1;
                if (defined $friendly_player_id and $2 eq $friendly_player_id) {
                    msg("Entity $1 is friendly");
                    $friendly_player_entity = $1;
                    $result_change = 1;
                }
                if (!$looked_up_records and scalar(keys %{$player_entities}) eq 2) {
                    msg("Looking up records");
                    lookup_records($player_entities, $friendly_player_entity, $friendly_hero, $current_enemy);
                    $looked_up_records = 1;
                    $result_change = 1;
                }
                next;
            }

            # see if a player conceded
            # [Power] PowerTaskList.DebugPrintPower() -     TAG_CHANGE Entity=rtba tag=PLAYSTATE value=CONCEDED
            if ($line =~ /\[Power\] PowerTaskList\.DebugPrintPower.+?TAG_CHANGE Entity=(.+?) tag=PLAYSTATE value=CONCEDED/) {
                my $entity = $1;
                $result_change = 1;
                if ($friendly_player_entity) {
                    if ($entity eq $friendly_player_entity) {
                        msg("Friendly player $entity conceded.");
                        $LOSSES++;
                        update_records($player_entities, $friendly_player_entity, $friendly_hero, $current_enemy, 0);
                    } else {
                        msg("Enemy player $entity conceded.");
                        $WINS++;
                        update_records($player_entities, $friendly_player_entity, $friendly_hero, $current_enemy, 1);
                    }
                } else {
                    msg("Could not store result, dont know who the good guy is");
                }
                $game_over = 1;
                next;
            }
            
	    if ($line =~ /TRANSITIONING card \[(.+?)\] to (FRIENDLY|OPPOSING) (PLAY|GRAVEYARD|PLAY|SECRET|HAND|DECK)/i or 
		$line =~ /TRANSITIONING card \[(.+)\] to\s*$/) {
		
		my $card_details = $1;
		my $player = $2;
		my $type = $3;
		my $is_hero = 0;
		if ($line =~ /\(Hero\)/i) {
		    $is_hero = 1;
		}
		my $is_hero_power = 0;
		if ($line =~ /\(Hero Power\)/i) {
		    $is_hero_power = 1;
		}

		# skip hero power lines
		next if ($is_hero_power);
		
		# figure out the card name and ID
		my $card_name;
		if ($card_details =~ /name=(.+?)\s\S+=/i) {
		    $card_name = $1;
		}
		my $card_id;
		if ($card_details =~ /id=(\d+)/i) {
		    $card_id = $1;
		}
		my $card_uuid;
		if ($card_details =~ /cardId=(\S+)/i) {
		    $card_uuid = $1;
		}
		my $card_type = "";
		if ($card_details =~ /type=(\S+)/) {
		    $card_type = $1;
		}
		my $player_id;
		if ($card_details =~ /player=(\d+)/i) {
		    $player_id = $1;
		}

		# this means we are starting a new game
		if ($is_hero and $player and $player eq "FRIENDLY" and $player_id) {
		    # identify the friendly player id
		    $friendly_player_id = $player_id;
		    $friendly_hero = $card_name;
		    msg("Playing as: $friendly_hero");
		    next;
		}

		# figure out who we are playing against
		if ($is_hero and $player and $player eq "OPPOSING") {
		    $current_enemy = $card_name;
		    msg("Playing against: $current_enemy");
		    next;
		}

		# sometimes it loses track of who the friendly player is
		if ($player and $player eq "FRIENDLY" and $player_id) {
		    $friendly_player_id = $player_id;
                    $friendly_player_entity = $player_entities->{$player_id};
		}

		my $zone;
		if ($card_details =~ /zone=(\S+)/i) {
		    $zone = $1;
		}
		if ($zone and $zone eq 'SETASIDE') {
		    # this is the result of a joust, ignore it
		    next;
		}
		if ($zone and $zone eq 'DECK' and !$type) {
		    # these are cards that come from the deck whenever there is a joust
		    next;
		}

		# see if the enemy player died
		if ($type and $type eq "GRAVEYARD") {
		    if ($player and $player eq "OPPOSING" and $current_enemy and $card_name eq $current_enemy) {
			msg("Game Over, Friendly player wins");
                        $WINS++;
                        update_records($player_entities, $friendly_player_entity, $friendly_hero, $current_enemy, 1);
                        $result_change = 1;
			$game_over = 1;
			next;
		    } elsif ($player and $player eq "FRIENDLY" and $friendly_hero and $card_name eq $friendly_hero) {
			msg("Game Over, Friendly player loses");
                        $LOSSES++;
                        update_records($player_entities, $friendly_player_entity, $friendly_hero, $current_enemy, 0);
                        $result_change = 1;
			$game_over = 1;
			next;
		    }
		}

		# keep track of spells
		if (!$player and !$type) {
		    if ($friendly_player_id ne $player_id) {
			msg("Enemy Spell: $card_name");
			$enemy_cards->{$card_name}++;
                        $result_change = 1;
		    } else {
			msg("Friendly Spell: $card_name");
		    }
		    next;
		}
		
		# ignore cards drawn by enemy
		next if ($player eq "OPPOSING" and $type =~ /HAND|DECK/);

		# see if its a card we mulliganned
		if ($card_type ne 'INVALID' and $player eq "FRIENDLY" and $type eq "DECK") {
		    $drawn_cards->{$card_name}--;
		    if ($drawn_cards->{$card_name} <= 0) {
			msg("Mulliganned: $card_name");
			delete($drawn_cards->{$card_name});
                        $result_change = 1;
			next;
		    }
		}	       
		
		# see if the opponent played a secret
		if ($player eq "OPPOSING" and $type eq "SECRET") {
		    msg("Enemy secret played");
		    $enemy_secrets->{$card_id} = undef;
                    $result_change = 1;
		    next;
		}
		
		# if the an enemy card went to the graveyard, see if it
		# was because a secret was revealed
		if ($player eq "OPPOSING" and $type eq "GRAVEYARD") {
		    if (exists $enemy_secrets->{$card_id}) {
			msg("Enemy secret revealed: $card_name");
			$enemy_secrets->{$card_id} = $card_name;
                        $result_change = 1;
			next;
		    }
		}
		
		# keep track of cards we've drawn
		if ($player eq "FRIENDLY" and $type eq "HAND") {
		    msg("Drew: $card_name");
		    # reset the drawn cards pool before we start logging if the game is over
		    if ($game_over) {
			$game_over = 0;
			# a new game is probably starting
			$drawn_cards = {};
			$enemy_cards = {};
			$enemy_secrets = {};
                        $player_entities = {};
                        $looked_up_records = 0;
		    }
		    $drawn_cards->{$card_name}++;
                    $result_change = 1;
		    next;
		} 

		# keep track of minions we played
		if ($player eq "FRIENDLY" and $type eq "PLAY") {
		    msg("Friendly minion: $card_name");
		    next;
		}
		
		# keep track of minions the enemy has played
		if (not $is_hero and $player eq "OPPOSING" and $type =~ /PLAY/)  {
		    msg("Enemy minion: $card_name");
		    $enemy_cards->{$card_name}++;
                    $result_change = 1;
		    next;
		}
	    }
	}
	# nothing new sleep a bit
	sleep 2;
    }
}

sub lookup_records {
    my ($player_ents, $friendly_ent, $friendly_hero, $curr_enemy) = @_;

    if ((scalar keys %{$player_ents} ne 2) or !$friendly_ent) {
        msg("Not looking up records, missing entity names");
        undef $MATCHUP_SINGLE;
        undef $MATCHUP_ALL;
        undef $MATCHUP_GLOBAL;
        return;
    }
    if (!$friendly_hero or !$curr_enemy) {
        msg("Not looking up records, missing hero names");
        undef $MATCHUP_SINGLE;
        undef $MATCHUP_ALL;
        undef $MATCHUP_GLOBAL;
        return;
    }

    my $enemy_ent;
    foreach my $ent (values %{$player_ents}) {
        if ($ent ne $friendly_ent) {
            $enemy_ent = $ent;
            last;
        }
    }

    my $matchup_single_r;
    my $matchup_all_r;
    my $matchup_global_r;

    $MATCHUP_SINGLE = "$friendly_hero v. $curr_enemy";
    $MATCHUP_ALL = "$friendly_ent v. $enemy_ent";
    $MATCHUP_GLOBAL = "$friendly_ent (as $friendly_hero)";
    open(RECORDS1, "<", "$CWD/hs_records.log") or return;
    
    my $hash = {};
    while ((!$matchup_single_r or !$matchup_all_r or !$matchup_global_r) and 
           my $line = <RECORDS1>) {
        chomp($line);
        
        if (!$matchup_single_r and $line =~ /^matchup_single;($friendly_ent);($friendly_hero);($curr_enemy);(\d+?);(\d+?)$/) {
            $matchup_single_r = "[$4 - $5]";
            next;
        }
        if (!$matchup_all_r and $line =~ /^matchup_all;($friendly_ent);($friendly_hero);($enemy_ent);(\d+?);(\d+?)$/) {
            $matchup_all_r = "[$4 - $5]";
            next;
        }
        if (!$matchup_global_r and $line =~ /^matchup_global;($friendly_ent);($friendly_hero);(\d+?);(\d+?)$/) {
            $matchup_global_r = "[$3 - $4]";
            next;
        }
    }
    close(RECORDS1);

    if (!$matchup_single_r) {
        $matchup_single_r = "[0 - 0]";
    }
    if (!$matchup_all_r) {
        $matchup_all_r = "[0 - 0]";
    }
    if (!$matchup_global_r) {
        $matchup_global_r = "[0 - 0]";
    }

    $MATCHUP_SINGLE .= " $matchup_single_r";
    $MATCHUP_ALL .= " $matchup_all_r";
    $MATCHUP_GLOBAL .= " $matchup_global_r";
}

sub update_records {
    my ($player_ents, $friendly_ent, $friendly_hero, $curr_enemy, $result) = @_;

    if ((scalar keys %{$player_ents} ne 2) or !$friendly_ent) {
        msg("Not logging result, missing entity names");
        return;
    }
    if (!$friendly_hero or !$curr_enemy) {
        msg("Not logging result, missing hero names");
        return;
    }

    open(RECORDS2, "<", "$CWD/hs_records.log");
    
    my $hash = {};
    while (my $line = <RECORDS2>) {
        chomp($line);
        if ($line =~ /^matchup_single;(.+?);(.+?);(.+?);(\d+?);(\d+?)$/) {
            $hash->{$1}->{$2}->{hero}->{$3}->{wins} = $4;
            $hash->{$1}->{$2}->{hero}->{$3}->{losses} = $5;
            next;
        }
        if ($line =~ /^matchup_global;(.+?);(.+?);(\d+?);(\d+?)$/) {
            $hash->{$1}->{$2}->{wins} = $3;
            $hash->{$1}->{$2}->{losses} = $4;
            next;
        }
        if ($line =~ /^matchup_all;(.+?);(.+?);(.+?);(\d+?);(\d+?)$/) {
            $hash->{$1}->{$2}->{matchup}->{$3}->{wins} = $4;
            $hash->{$1}->{$2}->{matchup}->{$3}->{losses} = $5;
            next;
        }
    }
    close(RECORDS2);

    my $enemy_ent;
    foreach my $ent (values %{$player_ents}) {
        if ($ent ne $friendly_ent) {
            $enemy_ent = $ent;
            if ($result) {
                $hash->{$friendly_ent}->{$friendly_hero}->{hero}->{$curr_enemy}->{wins} += 1;
                $hash->{$friendly_ent}->{$friendly_hero}->{matchup}->{$enemy_ent}->{wins} += 1;
                $hash->{$friendly_ent}->{$friendly_hero}->{wins} += 1;
            } else {
                $hash->{$friendly_ent}->{$friendly_hero}->{hero}->{$curr_enemy}->{losses} += 1;
                $hash->{$friendly_ent}->{$friendly_hero}->{matchup}->{$enemy_ent}->{losses} += 1;
                $hash->{$friendly_ent}->{$friendly_hero}->{losses} += 1;
            }

            my $w1 = $hash->{$friendly_ent}->{$friendly_hero}->{hero}->{$curr_enemy}->{wins} // 0;
            my $l1 = $hash->{$friendly_ent}->{$friendly_hero}->{hero}->{$curr_enemy}->{losses} // 0;
            my $w2 = $hash->{$friendly_ent}->{$friendly_hero}->{matchup}->{$enemy_ent}->{wins} // 0;
            my $l2 = $hash->{$friendly_ent}->{$friendly_hero}->{matchup}->{$enemy_ent}->{losses} // 0;
            my $w3 = $hash->{$friendly_ent}->{$friendly_hero}->{wins} // 0;
            my $l3 = $hash->{$friendly_ent}->{$friendly_hero}->{losses} // 0;

            $MATCHUP_SINGLE = "$friendly_hero v. $curr_enemy [$w1 - $l2]";
            $MATCHUP_ALL = "$friendly_ent v. $enemy_ent [$w2 - $l2]";
            $MATCHUP_GLOBAL = "$friendly_ent (as $friendly_hero) [$w3 - $l3]";

            last;            
        }
    }
    
    msg("Logging result between $friendly_ent and $enemy_ent ($friendly_hero vs $curr_enemy) (result:$result)");

    open(REC, ">", "$CWD/hs_records.log");
    foreach my $k1 (keys %{$hash}) {
        foreach my $k2 (keys %{$hash->{$k1}}) {
            my $hero = $hash->{$k1}->{$k2}->{hero};
            foreach my $k3 (keys %{$hero}) {
		my $losses = $hero->{$k3}->{losses} // 0;
		my $wins = $hero->{$k3}->{wins} // 0;
		
		my $line = "matchup_single;${k1};${k2};${k3};${wins};${losses}\n"; 
		print REC $line;
	    }
	    my $matchup = $hash->{$k1}->{$k2}->{matchup};
	    foreach my $k4 (keys %{$matchup}) {
                my $wins = $matchup->{$k4}->{wins} // 0;
                my $losses = $matchup->{$k4}->{losses} // 0;
                my $l2 = "matchup_all;${k1};${k2};${k4};${wins};${losses}\n";
                print REC $l2;
            }
            my $wins = $hash->{$k1}->{$k2}->{wins} // 0;
            my $losses = $hash->{$k1}->{$k2}->{losses} // 0;
            my $l = "matchup_global;${k1};${k2};$wins;$losses\n";
            print REC $l;
        }
    }
    close(REC);
}

# main

enable_logging();
init_player_log();
scan_player_log();
